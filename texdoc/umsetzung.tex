\section{Datenstruktur des Firmenkonglomerates}
Jede Firma wird in meiner Implementierung durch ein Objekt abgebildet, welches neben einer ID und dem Wert als Double auch eine Liste über alle unmittelbaren Nebenbedingungen enthält. Ich habe mich somit für die gängige Implementierung der Graphstruktur als Adjazenzliste entschiden. Da die einzige Operation auf dem Graphen eine Tiefensuche ist, ist die Adjazenzliste die geeigneteste Implementierung.\footnote{vgl. Sedgewick, Algorithmen: S. 563 (Deutsche Übersetzung der 4. Auflage)}

\section{Bestimmen der Nebenbedingungen jeder Firma}
Die Menge aller Nebenbedingungen eines Feldes \(A\) ist äquivalent zu den besuchten Knoten einer Tiefensuche von diesem Feld \(A\) aus. Schließlich ist es das Funktionsprinzip einer Tiefensuche, alle Felder abzusuchen, zu denen ein Pfad von einem Feld führt. Eine Tiefensuche funktioniert, indem zunächst alle angrenzenden Knoten des Feldes \(A\) (die Nebenbedingungen) auf einen Stapel\footnote{Stack, Stapel, Kellerspeicher: Linearere Datenstruktur, das zuletzt abgespeicherte Objekt ist das zuerst ausgegebene Objekt (FIFO-Prinzip)} gespeichert werden.
Außerdem wird \(A\) der Besucht-Menge hinzugefügt. Alle Felder auf dem Stapel werden nun ebenfalls der Menge hinzugefügt. Die an diese Felder angrenzenden Felder werden widerum auf den Stapel gelegt, sodenn sie nicht schon in der Besucht-Menge liegen. So wird jedes Feld, zu dem von \(A\) ein Pfad führt, aufgelistet. Diese Besucht-Menge entspricht daher der Teilmenge von \(G\), die beim Kauf von \(A\) mitgekauft werden muss. Der Algorithmus kann sich nicht in einem Zyklus verfangen, da wiederholte Besuche eines Feldes aufgrund der Besucht-Menge verhindert werden.  Bei der Tiefensuche ermittele ich außerdem, ob eine negativwertige Firma unter den angrenzenden Firmen liegt. Dies ist wie in der Lösungsidee beschrieben, zur Beschleunigung des Algorithmusses relevant. Ob eine negativwertige Firma in der Ergebnismenge enthalten ist, speichere ich einem Array.

\begin{table}
	\centering
    \begin{tabular}{l|ccccccccc}
    Firma 	& A & B & C & D & E & F & I & R & Z \\ \hline
    \(M_A\)	& 1 & 0 & 1 & 1 & 0 & 0 & 0 & 1 & 0 \\
    \(M_B\)	& 0 & 1 & 0 & 0 & 1 & 0 & 1 & 1 & 0 \\ \hhline{=|*{9}{=}}
    ODER 	& 1 & 1 & 1 & 1 & 1 & 0 & 1 & 1 & 0 \\
    \end{tabular}
    \caption {Vereinigung entspricht ODER}
    \label{tab:veroder}
\end{table}
Zentral für die Umsetzung der Lösungsidee ist die effiziente Abbildung der Besucht-Menge im Speicher. Naheliegend ist die Verwendung der Klasse Set, jedoch ist diese bei genauerer Betrachtung nicht optimal. Sinnvoller ist die Verwendung eines BitSets. Ein BitSet besteht in Java aus einer Abfolge von \(n\) binären Bits. Für unsere Anwendung werden soviele Bits benötigt wie der Graph Knoten hat. Jedes Bit repräsenteirt hierbei eine Firma. Steht das Bit \textit{n} auf 1, befindet sich die \textit{n}te Firma in der durch das BitSet repräsentierte Menge, steht es auf 0, befindet sich die Firma nicht in der Teilmenge. Die Verknüpfung zweier Mengen entspricht einer nicht-exklusive ODER-Verbindung (siehe Tabelle \ref{tab:veroder}. Das BitSet ist besser geeignet, da anstatt der jeweiligen Firmennummern als 32bit-Integer nur einzelne Bits abgespeichert werden müssen. Außerdem gelingt die Vereinigung zweier Firmen schneller. Ein weiterer Vorteil des BitSets ist, dass es wahlfreien Zugriff unterstützt, während ein Set in der Standardimplementierung nur über Iteratoren auslesbar ist.

\section{Aufstellen des Baumes}
Für die vollständige Suche nach der besten Kombination habe ich eine neue Datenstruktur, ein \textit{BufferedSet}, implementiert. Ein BufferedSet besteht aus einem Set, auf das nur lesend zugegeriffen werden kann und einem Puffer, auf den wiederum nur schreibend zugegriffen werden kann. Neue Einträge werden zunächst auf den Puffer geschrieben und zu einem späteren Zeitpunkt gesammelt dem Set hinzugefügt. Der Vorteil dieser Datenstruktur ist, dass auf das BufferedSet geschrieben werden kann, während über das Set iteriert wird. Der Iterator des Sets bleibt stabil, die während der Iteration geschriebenen Daten werden während der weiteren Iteration nicht ausgelesen. Erst nach der Iteration werden sie dem Set über den gesammelten Schreibvorgang hinzugefügt. Der Puffer ist als Stack implementiert, da bei einem Set die Reihenfolge des Einfügens irreleveant ist.

Genutzt wird das BufferedSet im Kontext der Suche nach der besten Menge. In einem ersten Schritt fasse ich alle Teilmengen, die während der Tiefensuche als "`Win-Win-Menge"' identifiziert wurden, zu einer Startmenge zusammen. Mit dieser dieser Menge, repräsentiert durch ein BitSet, initialisere ich mein BufferedSet. Darüber hinaus speichere ich in zwei seperaten Variablen den Wert und die Firmen der bisher besten Teilmenge. Auch diese Variablen werden mit den Daten der "`Win-Win-Menge"' initialisiert. 
Danach füge ich dem BufferedSet die Kombinationen aus den bisher errechneten Varianten, also Anfangs der "`Win-Win-Menge"', und dem Kauf einer beliebigen positivwertigen Firma hinzu. Dies wiederhole ich für jede positivwertige Firma, deren Kauf nicht in der "`Win-Win-Menge"' berücksichtigt wurde. So baue ich einen binären Baum über jede möglich Kaufentscheidung auf. Falls dabei eine Menge gefunden wird, deren Wert höher als das bisherige Maximum ist, speichere ich diese Menge und ihren Wert in den entsprechenden Maximumsvariablen. So finde ich mit absoluter Sicherheit die günstigste Kombination. Durch die Implemenentation des Baumes als BufferedSet, also einer linearen Datenstruktur, verliere ich die Information, in welcher Generation sich eine Menge befindet. Diese Information ist für meinen Algorithmus aber von keiner Relevanz, vielmehr verhindere ich durch die Nutzung des Sets, dass eine gleiche Teilmenge mehrmals evaluiert wird.

\section{Implementierung der Heuristik}