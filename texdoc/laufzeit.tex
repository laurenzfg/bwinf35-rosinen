Relevant für die Beurteilung der Gesamtlaufzeit sind der Baumaufbau und etwaige Heuristikdurchläufe.

Wie schon in der Lösungsidee geschildert, gibt es bei meinem Programm zwei Modi. Solange eine maximale Baumgröße nicht überschritten wird, wird der Baum komplett aufgebaut.
Da sich die Anzahl der Elemente im Baum, die mit anderen Elementen verknüpft werden müssen und von denen der Wert berechnet werden muss, sich bei jedem Durchlauf verdoppelt, gilt für diesen Codeteil eine Komplexität von \(\mathcal{O}(2^{pm})\). \(pm\) ist hierbei wie in der Lösungsidee definiert. 

Sobald \(2^{pm}\) allerdings die obere Schranke der maximalen Elementzahl überschreitet, gilt folgende Laufzeitkomplexität für den Baumaufbauteil:

\begin{gather}
	{hHeur} = max - \frac{p}{100} \times max \\
	{nHeur} = \frac{V-max}{max} \\
	{rem}   = h-max \bmod max \\
	\mathcal{O}(max+nHeur\times{}(max-2^{hHeur})+(2^{hHeur + rem}-2^{rem}))
\end{gather}

Zunächst wird ein Baum von der Größe Max aufgebaut. Danach wird so oft die Heuristik aufgerufen, bis alle Firmen berücksichtigt worden sind. Pro Heuristikdurchlauf werden soviel Knoten hinzugefügt, wie die Differenz zwischen dem nächsten Heuristikdurchlauf (max) und den übrig gelassenen Knoten beträgt. Schließlich wird noch der Teilbaum für den Rest nach dem letzten Heuristikdurchlauf aufgebaut.

Hinzu kommt noch die Laufzeit für die Sortierungen, die allerdings aufgrund der Parallelisierung stark von der Anzahl der Prozessorkerne abhängt.
